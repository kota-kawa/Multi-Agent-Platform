1. IoTエージェントのデバイス・機能管理 (multi_agent_app/iot.py)

   * 現状:
      _fetch_iot_device_context
  関数などで、IoTデバイスのリストや操作可能なコマンドを動的に取得し、それをテキストとして整形してLLMのプロンプト（_format_device_context）に埋め込んでいます。
   * MCPのメリット (Tools / Resources):
      IoTエージェントを「MCPサーバー」として実装し、各デバイスの操作を MCP Tools として定義できます。
       * 利点:
         オーケストレーター側で「どのようなプロンプトを作るか」を工夫する必要がなくなり、MCPクライアントとし
         て接続するだけで、利用可能なデバイス（ツール）が自動的に認識されます。新しいデバイスが増えてもオーケストレーターのコード修正が不要になります。
       * Resources: デバイスの現在の状態を MCP Resources
         として公開すれば、常に最新の状態を標準的な方法で取得できます。

  2. オーケストレーターのプランニング・ツール定義 (multi_agent_app/orchestrator.py)

   * 現状:
      MultiAgentOrchestrator クラス内の _plan_node
  メソッドなどで、各エージェントができることを自然言語のプロンプトとしてLLMに伝えています。新しいエージェン
  トを追加するには、このプロンプトと呼び出しロジックの両方を修正する必要があります。
   * MCPのメリット (Dynamic Tool Discovery):

  オーケストレーターを「MCPクライアント」化することで、接続されたエージェント（MCPサーバー）から動的にツール定義を取得できます。
       * 利点: 「Browser Agent」や「Scheduler　Agent」が自ら「自分はこれができる（ツール定義）」を提示するため、オーケストレーター側のプロンプト管理が劇的にシンプルになります。エージェントの追加・削除が設定ファイル（接続先URLなど）の変更だけで完結するようになります。

  3. メモリ管理 (multi_agent_app/memory_manager.py)

   * 現状:
      json ファイル（short_term_memory.json 等）を直接読み書きしています。
   * MCPのメリット (Resources):
      記憶領域を MCP Resources として抽象化できます。
       * 利点: 単なるファイル読み書きではなく、URI（例:
         memo://short_term/latest）を通じてコンテキストにアクセスできるようになります。これにより、ローカルファイルだけでなく、将来的にデータベースやクラウドストレージに移行しても、エージェント側のコードを変更する必要がなくなります。

  4. ブラウザエージェントのコンテキスト共有 (multi_agent_app/browser.py)

   * 現状:
      HTTPリクエストで指示を送り、SSE (Server-Sent Events) で結果を受け取る独自の仕組みになっています。
   * MCPのメリット (Prompts / Context):
      ブラウザエージェントが現在見ているページの要約やスクリーンショット情報を MCP Resourcesとして提供したり、ブラウザ操作用の定型タスクを MCP Prompts として定義できます。
       * 利点:
         オーケストレーターが「今のページの内容を教えて」と問い合わせる際、標準化されたプロトコルでコンテキストを取得でき、トークン節約や精度向上につながります。

  まとめ

  現在の「HTTPリクエスト + 独自プロンプト構築」という構成は、MCPの Client-Server アーキテクチャ
  に非常に適しています。

  最も効果が高い導入ステップ案:
   1. IoTエージェント: デバイス操作を Tools 化（効果が最も分かりやすい）。
   2. メモリ管理: JSON操作を Resources 化。
   3. オーケストレーター: これらを統合するMCPクライアント機能の実装。

   これにより、コードの結合度が下がり、各エージェントが独立して進化できる疎結合なシステムになります。

補足: Life-Assistant-Agent 側で `mcp_server.py` を追加し、`rag_answer` / `analyze_conversation` を MCP Tools として公開済み。オーケストレーターを MCP クライアント化するときは、Life-Assistant を最初の接続先として組み込み、家庭科系の応答と会話分析を動的に取得できる。
補足2: Life-Assistant-Agent は `/mcp/sse` / `/mcp/messages` で MCP ブリッジを提供し、Multi-Agent-Platform 側は `LIFESTYLE_USE_MCP`（デフォルトON）で HTTP より先に MCP を使って呼び出します。HTTP フォールバックは従来どおり維持されます。
